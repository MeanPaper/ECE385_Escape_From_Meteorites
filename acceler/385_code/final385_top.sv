
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================
//
//module 385_acc(
//
//	//////////// CLOCK //////////
//	input 		          		ADC_CLK_10,
//	input 		          		MAX10_CLK1_50,
//	input 		          		MAX10_CLK2_50,
//
//	//////////// SDRAM //////////
//	output		    [12:0]		DRAM_ADDR,
//	output		     [1:0]		DRAM_BA,
//	output		          		DRAM_CAS_N,
//	output		          		DRAM_CKE,
//	output		          		DRAM_CLK,
//	output		          		DRAM_CS_N,
//	inout 		    [15:0]		DRAM_DQ,
//	output		          		DRAM_LDQM,
//	output		          		DRAM_RAS_N,
//	output		          		DRAM_UDQM,
//	output		          		DRAM_WE_N,
//
//	//////////// SEG7 //////////
//	output		     [7:0]		HEX0,
//	output		     [7:0]		HEX1,
//	output		     [7:0]		HEX2,
//	output		     [7:0]		HEX3,
//	output		     [7:0]		HEX4,
//	output		     [7:0]		HEX5,
//
//	//////////// KEY //////////
//	input 		     [1:0]		KEY,
//
//	//////////// LED //////////
//	output		     [9:0]		LEDR,
//
//	//////////// SW //////////
//	input 		     [9:0]		SW,
//
//	//////////// VGA //////////
//	output		     [3:0]		VGA_B,
//	output		     [3:0]		VGA_G,
//	output		          		VGA_HS,
//	output		     [3:0]		VGA_R,
//	output		          		VGA_VS,
//
//	//////////// Accelerometer //////////
//	output		          		GSENSOR_CS_N,
//	input 		     [2:1]		GSENSOR_INT,
//	output		          		GSENSOR_SCLK,
//	inout 		          		GSENSOR_SDI,
//	inout 		          		GSENSOR_SDO,
//

//
//);

//===========================================================================
// accel.v
//
// Template module to get the DE10-Lite's accelerator working very quickly.
//
// 2020/05/17  Written (BB)
//
//===========================================================================

module final385_top(
   //////////// CLOCK //////////
   input 		          		ADC_CLK_10,
   input 		          		MAX10_CLK1_50,
   input 		          		MAX10_CLK2_50,

   //////////// SEG7 //////////
   output		     [7:0]		HEX0,
   output		     [7:0]		HEX1,
   output		     [7:0]		HEX2,
   output		     [7:0]		HEX3,
   output		     [7:0]		HEX4,
   output		     [7:0]		HEX5,
	
	//////////// SDRAM //////////
	output		    [12:0]		DRAM_ADDR,
	output		     [1:0]		DRAM_BA,
	output		          		DRAM_CAS_N,
	output		          		DRAM_CKE,
	output		          		DRAM_CLK,
	output		          		DRAM_CS_N,
	inout 		    [15:0]		DRAM_DQ,
	output		          		DRAM_LDQM,
	output		          		DRAM_RAS_N,
	output		          		DRAM_UDQM,
	output		          		DRAM_WE_N,

   //////////// KEY //////////
   input 		     [1:0]		KEY,

   //////////// LED //////////
   output		     [9:0]		LEDR,

   //////////// SW //////////
   input 		     [9:0]		SW,

   //////////// Accelerometer ports //////////
   output		          		GSENSOR_CS_N,
   input 		     [2:1]		GSENSOR_INT,
   output		          		GSENSOR_SCLK,
   inout 		          		GSENSOR_SDI,
   inout 		          		GSENSOR_SDO,
	
	
	///////// VGA /////////
	output             VGA_HS,
	output             VGA_VS,
	output   [ 3: 0]   VGA_R,
	output   [ 3: 0]   VGA_G,
	output   [ 3: 0]   VGA_B,
	
	
	//////////// Arduino //////////
	inout 		    [15:0]		ARDUINO_IO,
	inout 		          		ARDUINO_RESET_N
   );

//===== Declarations
   localparam SPI_CLK_FREQ  = 200;  // SPI Clock (Hz)
   localparam UPDATE_FREQ   = 1;    // Sampling frequency (Hz)

   // clks and reset
   logic Reset_h;
   logic clk, spi_clk, spi_clk_out;
	logic vssig, blank, sync, VGA_Clk;

	logic SPI0_CS_N, SPI0_SCLK, SPI0_MISO, SPI0_MOSI, USB_GPX, USB_IRQ, USB_RST;
	logic [3:0] hex_num_4, hex_num_3, hex_num_1, hex_num_0; //4 bit input hex digits
	logic [1:0] signs;
	logic [1:0] hundreds;
   logic [23:0] keycode_temp; //24 bit keycode, can deal with 3 keycode

	
	
   // output data
   logic data_update;
   logic [15:0] data_x, data_y;
	
	
	
	logic [9:0] drawxsig, drawysig, ballxsig, ballysig, ballsizesig;
	logic [7:0] Red, Blue, Green;

	
	assign VGA_R = Red[7:4];
	assign VGA_B = Blue[7:4];
	assign VGA_G = Green[7:4];
//===== Phase-locked Loop (PLL) instantiation. Code was copied from a module
//      produced by Quartus' IP Catalog tool.
//ip ip_inst (
//   .inclk0 ( MAX10_CLK1_50 ),
//   .c0 ( clk ),                 // 25 MHz, phase   0 degrees
//   .c1 ( spi_clk ),             //  2 MHz, phase   0 degrees
//   .c2 ( spi_clk_out )          //  2 MHz, phase 270 degrees
//   );
//
////===== Instantiation of the spi_control module which provides the logic to 
////      interface to the accelerometer.
//spi_control #(     // parameters
//      .SPI_CLK_FREQ   (SPI_CLK_FREQ),
//      .UPDATE_FREQ    (UPDATE_FREQ))
//   spi_ctrl (      // port connections
//      .reset_n    (1'b1),
//      .clk        (clk),
//      .spi_clk    (spi_clk),
//      .spi_clk_out(spi_clk_out),
//      .data_update(data_update),
//      .data_x     (data_x),
//      .data_y     (data_y),
//      .SPI_SDI    (GSENSOR_SDI),
//      .SPI_SDO    (GSENSOR_SDO),
//      .SPI_CSN    (GSENSOR_CS_N),
//      .SPI_CLK    (GSENSOR_SCLK),
//      .interrupt  (GSENSOR_INT)
//   );

//===== Main block
//      To make the module do something visible, the 16-bit data_x is 
//      displayed on four of the HEX displays in hexadecimal format.

// Pressing KEY0 freezes the accelerometer's output
//assign reset_n = KEY[0];

assign {Reset_h}=~ (KEY[0]);

	//=======================================
	assign ARDUINO_IO[10] = SPI0_CS_N;
	assign ARDUINO_IO[13] = SPI0_SCLK;
	assign ARDUINO_IO[11] = SPI0_MOSI;
	assign ARDUINO_IO[12] = 1'bZ;
	assign SPI0_MISO = ARDUINO_IO[12];
	
	assign ARDUINO_IO[9] = 1'bZ; 
	assign USB_IRQ = ARDUINO_IO[9];
		
	//Assignments specific to Circuits At Home UHS_20
	assign ARDUINO_RESET_N = USB_RST;
	assign ARDUINO_IO[7] = USB_RST;//USB reset 
	assign ARDUINO_IO[8] = 1'bZ; //this is GPX (set to input)
	assign USB_GPX = 1'b0;//GPX is not needed for standard USB host - set to 0 to prevent interrupt
	
	//Assign uSD CS to '1' to prevent uSD card from interfering with USB Host (if uSD card is plugged in)
	assign ARDUINO_IO[6] = 1'b1;
	
	//HEX drivers to convert numbers to HEX output
//	HexDriver hex_driver4 (hex_num_4, HEX4[6:0]);
//	assign HEX4[7] = 1'b1;
//	
//	HexDriver hex_driver3 (hex_num_3, HEX3[6:0]);
//	assign HEX3[7] = 1'b1;
//	
//	HexDriver hex_driver1 (hex_num_1, HEX1[6:0]);
//	assign HEX1[7] = 1'b1;
//	
//	HexDriver hex_driver0 (hex_num_0, HEX0[6:0]);
//	assign HEX0[7] = 1'b1;
//	
//	//fill in the hundreds digit as well as the negative sign
//	assign HEX5 = {1'b1, ~signs[1], 3'b111, ~hundreds[1], ~hundreds[1], 1'b1};
//	assign HEX2 = {1'b1, ~signs[0], 3'b111, ~hundreds[0], ~hundreds[0], 1'b1};
	
	HexDriver hexs [5:0](.In0(keycode_temp), .Out0({HEX5[6:0], HEX4[6:0], HEX3[6:0], HEX2[6:0], HEX1[6:0], HEX0[6:0]}));
	
	//=======================================


	final_project_platform u0 (
		.clk_clk                           (MAX10_CLK1_50),  //clk.clk
		.reset_reset_n                     (1'b1),           //reset.reset_n
		.altpll_0_locked_conduit_export    (),               //altpll_0_locked_conduit.export
		.altpll_0_phasedone_conduit_export (),               //altpll_0_phasedone_conduit.export
		.altpll_0_areset_conduit_export    (),               //altpll_0_areset_conduit.export
		.key_external_connection_export    (KEY),            //key_external_connection.export

		//SDRAM
		.sdram_clk_clk(DRAM_CLK),                            //clk_sdram.clk
		.sdram_wire_addr(DRAM_ADDR),                         //sdram_wire.addr
		.sdram_wire_ba(DRAM_BA),                             //.ba
		.sdram_wire_cas_n(DRAM_CAS_N),                       //.cas_n
		.sdram_wire_cke(DRAM_CKE),                           //.cke
		.sdram_wire_cs_n(DRAM_CS_N),                         //.cs_n
		.sdram_wire_dq(DRAM_DQ),                             //.dq
		.sdram_wire_dqm({DRAM_UDQM,DRAM_LDQM}),              //.dqm
		.sdram_wire_ras_n(DRAM_RAS_N),                       //.ras_n
		.sdram_wire_we_n(DRAM_WE_N),                         //.we_n

		//USB SPI	
		.spi0_SS_n(SPI0_CS_N),
		.spi0_MOSI(SPI0_MOSI),
		.spi0_MISO(SPI0_MISO),
		.spi0_SCLK(SPI0_SCLK),
		
		//USB GPIO
		.usb_rst_export(USB_RST),
		.usb_irq_export(USB_IRQ),
		.usb_gpx_export(USB_GPX),
		
		//LEDs and HEX and SW
		.hex_digits_export({hex_num_4, hex_num_3, hex_num_1, hex_num_0}),
		//.leds_export({hundreds, signs, LEDR}),
		.keycode_export(keycode_temp),
		.switch_export(SW)
		);


		assign LEDR = {bullet_hit,obstacle_activate[0], obstacle_activate[1],
							obstacle_activate[2], obstacle_activate[3]};


// 7-segment displays HEX0-3 show data_x in hexadecimal
//HexDriver s0 (
//   .In0      (data_x[4:0]),
//   .Out0 (HEX0) );
//
//HexDriver s1 (
//   .In0      (data_x[7:5]),
//   .Out0 (HEX1) );
//
//HexDriver s2 (
//   .In0      (data_x[11:8]),
//   .Out0 (HEX2) );
//
//HexDriver s3 (
//   .In0      (data_x[15:12]),
//   .Out0 (HEX3) );

// A few statements just to light some LEDs
//HexDriver s4 ( .In0(SW[5:2]), .Out0(HEX4) );
//HexDriver s5 ( .In0(SW[9:6]), .Out0(HEX5) );
//assign LEDR = {SW[9:8], data_x[7:0]};

	//vga module
	vga_controller vga (
					.Clk(MAX10_CLK1_50),
					.Reset(Reset_h),
					.hs(VGA_HS),
					.vs(VGA_VS),
					.pixel_clk(VGA_Clk),
					.blank,
					.sync,
					.DrawX(drawxsig),
					.DrawY(drawysig)
	
	);
	
	
	//ball module 
	ball_two b( 	//input
					.Reset(Reset_h), 
					.frame_clk(VGA_VS),
					//.data_x,
					//.data_y,
					.enemy_x(object_X), 
					.enemy_y(object_Y), 
					.enemy_size(object_Size),
					.keycode(keycode_temp),
					.enermy_alive(obstacle_activate),
					//.mode_sw(SW[0]),
					
					//output
					.BallX(ballxsig),
					.BallY(ballysig), 
					.BallS(ballsizesig)
					//,Ball_die
	);
	
	
	logic [9:0] object_Size[4], object_X[4], object_Y[4];
	logic obstacle_activate[4];
	
	obstacle	obj(   
					//input
					.Reset(Reset_h), 
					.frame_clk(VGA_VS),
					.ball_ammo_x(bullet_X_out),
					.ball_ammo_y(bullet_Y_out),
					.ball_ammo_size(bullet_size),
					
					//output
					.bullet_hit,   // bullet hit the object
					.object_Size, //object size
					.object_X, 
					.object_Y,   //, //object location
					.obstacle_activate		  //the object is on
				);

	logic [9:0] bullet_X_out, bullet_Y_out, bullet_size;
	logic bullet_active, bullet_hit;
	bullet	ammo(  	
					//input
               .bullet_X(ballxsig), //the bullet appears at the tip of the plane 
					.bullet_Y(ballysig - (ballsizesig >> 2)), //this is for the ball location - the ball_size
                	
               .Reset(Reset_h),                    //reset the bullets
               .frame_clk(VGA_VS),                //clk to control the bullet
               .space_key(keycode_temp),          //space key is hit

					//output
					
					.bullet_hit,               //if bullet hit something then it disappear
               .bullet_active,           //the bullet is still active
               .bullet_X_out, 
					.bullet_Y_out, 
					.bullet_size
            	);
					
	//color mapper module
	color_mapper	color0(

					//x position drawing and y position drawing
					.DrawX(drawxsig), 
					.DrawY(drawysig), 
					.blank,
					.pixel_clk(VGA_Clk),

					//player
					.BallX(ballxsig), 
					.BallY(ballysig), 
					.Ball_size(ballsizesig),
					
					//obstacle
					.Obj_X(object_X), 
					.Obj_Y(object_Y), 
					.Obj_Size(object_Size),
					.Obj_act(obstacle_activate),
					
					//bullet data
					.bullet_x(bullet_X_out),
					.bullet_y(bullet_Y_out),
					.bullet_size,
					.bullet_activate(bullet_active),
					
					//color display
					.Red, 
					.Green, 
					.Blue 
	);

	


endmodule
//keycode should be 21 bit to accept two direction key and a shooting key 


//=======================================================
//  REG/WIRE declarations
//=======================================================




//=======================================================
//  Structural coding
//=======================================================



